% moving dot propellers, one propeller has some coherent motion% uses DrawDots.mex which is a modification of the DOTS.mex package from% Shadlen% dot motion written by Keith Schneider, 1999 September 24,26% ks cleaned up 10/12/99% ks stim_seq mod 5/1/03% propeller, half coherence, record button presses: ks% auto save: ks 9/21/04% changed to one wedge, added calculations for misses, HR, FAR: ma 11/22/06clearclear all;clear mex;rand('state',sum(100*clock))filename=input('Input filename: ','s');% resp_key = 50; %spacebarresp_key=22; %for scanner, first buttonp.period = 40;	% period of each cycle in secp.beg_blank_time = 2;	% blank time at beginningp.end_blank_time = 0;p.ncycles = 8;% create color look-up table (CLUT)BLACK_INDEX		= [0 0 0];GRAY_INDEX		= [50 50 50];RED_INDEX		= [255 0 0];BLUE_INDEX 		= [0 0 255];WHITE_INDEX 	= [255 255 255];% ---------------% open the Screen% ---------------whichScreen=1;[wp, rect] = Screen('OpenWindow', whichScreen, 8);	% open main Screenp.frame_rate=Screen('FrameRate', wp);	% frames per second[keyIsDown, secs, keycode] = KbCheckMulti; %check responseHideCursor;	% Hide the mouse cursor% Enable alpha blending for contrast manipulations (for drawing circular dots)Screen('BlendFunction', wp, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); % -----------------------------% set the experiment parameters% -----------------------------p.mon_width  	= 39;	% horizontal dimension of viewable Screen (in cm)p.v_dist 		= 60;	% viewing distance (in cm)p.norm_speed 	= 7;	% normal dot speed (deg/sec)p.ndots 		= 1000;	% number of dotsp.max_d 		= 15;	% maximum radius of  annulus (degrees)p.min_d 		= 1;	% minumump.th_min = [0; pi];p.th_max = [pi/4; 5*pi/4];p.th0 = -pi/8;%p.th0 = 2.77;%p.n_prop = length(p.th_min);	% number of propellersp.n_prop = 1p.dotsize = 6;p.switch_coh_min = 1;p.switch_coh_max = 1;p.fcoh = .9;	% fraction of coherent dotsp.fkill = 0.01; 	% fraction of dots to kill each frame% -------------% set up arrays% -------------pix_per_deg = pi * rect(3) / atan(p.mon_width/p.v_dist/2) / 360;	% pixels per degreeds_to_pf = pix_per_deg / p.frame_rate;	% conversion factor from deg/sec to pixels/framepfs = p.norm_speed * ds_to_pf;	% normal dot speed (pixels/frame)% -----------------------------------% set up dot positions and velocities% -----------------------------------rmax = p.max_d * pix_per_deg;	% maximum radius of annulus (pixels from center)rmin = p.min_d * pix_per_deg; 	% minimumr = rmax * sqrt(rand(p.ndots,1));	% rr(r<rmin) = rmin;pn = floor(p.n_prop*rand(p.ndots,1))+1;	% propeller assignment number for each dott = rand(p.ndots,1).*(p.th_max(pn)-p.th_min(pn))+p.th_min(pn)+p.th0;	% thetaxy = [r r] .* [cos(t), sin(t)];	% dot positions in Cartesian pixel coordinates relative to centermdir = 2*pi*rand(p.ndots,1);	% motion direction for each dotcoh = rand(p.ndots,1) < p.fcoh & pn == 1;	% the coherently moving dotscohdir = 2*pi*rand;mdir(coh) = cohdir; 	% direction of coherent motion;dxdy = pfs * [cos(mdir), sin(mdir)];	% change in x and y (in pixels) per framexdots = zeros(p.ndots,2);				% [x, y, color, size] for each dot to be drawn%LogFile PARAMETERS%______________________________%MAX_TRIALS=65behav_data=[];down_one=[];up_one=[];% --------------------% start experiment now: draw fixation point and text and wait for key press to begin% --------------------xy0 = [rect(3) rect(4)]/2;	% center of Screen (pixel coordinates)fix_cord = [xy0-4 xy0+4];Screen('FillRect', wp, BLACK_INDEX);Screen('FillRect', wp, RED_INDEX, fix_cord);	% fixation dotScreen('FillRect', wp, BLACK_INDEX, [fix_cord(1)+2, fix_cord(2)+2, fix_cord(3)-2, fix_cord(4)-2]);	% fixation dottxt = 'Wait for scanner to begin';txtloc = [xy0(1) - length(txt) * 7 / 2, xy0(2) + 40];[newX newY] = Screen('DrawText', wp, txt,txtloc(1),txtloc(2),RED_INDEX);Screen('Flip', wp);FlushEvents('keydown');[keyIsDown, secs, keycode] = KbCheckMulti; %check responsewhile ~keyIsDown    [keyIsDown, secs, keycode] = KbCheckMulti; %check response    waitsecs(.01);endScreen('FillRect', wp, BLACK_INDEX);Screen('FillRect', wp, RED_INDEX, fix_cord);	% fixation dotScreen('FillRect', wp, BLACK_INDEX, [fix_cord(1)+2, fix_cord(2)+2, fix_cord(3)-2, fix_cord(4)-2]);	% fixation dotScreen('Flip', wp);WaitSecs(p.beg_blank_time);start_time = GetSecs;c_switch_time = p.switch_coh_min + rand * (p.switch_coh_max-p.switch_coh_min);nswitch = 0;nkeypress = 0;start_resp_time=GetSecs;step_size=.05;resp_interval=1;check = 0;ikp = 1;cohnum=1;trial_num=1;check_prior=0;falsecounter=0;correctpress=0;behav_data=[behav_data;0,0,0,0,0,0,0];behav_data(1,1)=p.fcoh;behav_data(1,3)=cohdir;up_one=[up_one;0]down_one=[down_one;0]p.th0 = pi/8 ;%p.th0 = 2.75 ;while GetSecs-start_time <= p.ncycles * p.period   %cycle dependant    % while trial_num <= MAX_TRIALS  %trial number dependant    thetime = GetSecs-start_time;    %	th = [2*pi*thetime/p.period+p.th0];   % For Clockwise    th = -[2*pi*thetime/p.period+p.th0];  %For Counterclockwise rotation    behav_data(trial_num,1)=trial_num;    behav_data(trial_num,2)=p.fcoh;    behav_data(trial_num,3)=cohdir;            if thetime > c_switch_time & thetime < p.ncycles * p.period        trial_num=trial_num+1;        nswitch=nswitch+1;        behav_data=[behav_data;0,0,0,0,0,0,0];        behav_data(trial_num,4)=c_switch_time;        % 		down_one=[down_one;0]        % 		up_one=[up_one;0]                        c_switch_time = c_switch_time + p.switch_coh_min + rand * (p.switch_coh_max-p.switch_coh_min);                %Randomize direction change---------------------        new=rand;        if new < .5            cohdir = cohdir + [pi*75/180+(pi*105/180-pi*75/180)*rand]; %random number between 75 and 105 degrees            cohnum=cohnum+1;        else            cohdir = cohdir - [pi*75/180+(pi*105/180-pi*75/180)*rand];	%random number between 75 and 105 degrees            cohnum=cohnum+1;        end        %End of randomize direction change---------------                % 		%Staircase Begin---------------        % 		if trial_num>1 & behav_data(trial_num-1, 5)==0 % as long as not first trial, and subject missed previous trial        % 			if p.fcoh <1.00        % 			p.fcoh= p.fcoh+step_size; %make easier for this trial        %  			up_one(trial_num)=1%record we went up 1        % 			end        % 			if down_one(trial_num-1)==1; %if went down one (harder) in prev trial, then reversal        % 				behav_data(trial_num+1, 7)=1;        % 			end        %        % 		elseif trial_num > 2 & all(behav_data(trial_num-2:trial_num-1, 5)==1) & all(down_one(trial_num-1)==0)        % 			%3down, 1up: elseif trial_num > 3 & all(behav_data(trial_num-3:trial_num-1, 3)==1) & all(down_one(trial_num-2:trial_num-1)==0)        % 							%if trial>3, and prev 3 trials correct, and didn't get harder in last two trials        % 			if p.fcoh-step_size > 0%while still able to decrement speed        % 				p.fcoh=p.fcoh-step_size;        % 				down_one(trial_num)=1; % record that we went down (got harder)        % 			end        % 			if up_one(trial_num-2)==1 % if 'prev' trial was up one, then reversal        % 				behav_data(trial_num+1, 7)=1;        % 			end        % 		end        %        % 		%Staircase End---------------                                % %Change Step-Size Begin ---------------        % 		if nswitch > 30        % 			if correctpress/nswitch < 65        % 				step_size =.025;        % 			end        % 			if correctpress/nswitch < 55        % 				step_size = .01;        % 			end        % 			if correctpress/nswitch > 65        % 				step_size = .05;        % 			end        % 		end        % %Change Step-Size Begin ---------------                        coh = rand(p.ndots,1) < p.fcoh & pn == 1;	% the coherently moving dots        mdir(coh) = cohdir;        start_resp_time=GetSecs;        check = 1; %check for responses        tswitch(nswitch) = thetime;    end        dxdy = pfs * [cos(mdir), sin(mdir)];	% change in x and y (in pixels) per frame        % -------------------------------------------------    % update the dot positions for the next video frame    % -------------------------------------------------        xy = xy + dxdy;						% move dots        % check to see which dots have gone beyond the borders of the annuli        r2 = xy(:,1).^2 + xy(:,2).^2;    r_out = r2 > rmax^2 | r2 < rmin^2;				% dots past outer border of central annulus        t = mod(atan2(xy(:,2),xy(:,1)),2*pi);    tb_min = mod(p.th_min+th,2*pi);    tb_max = mod(p.th_max+th,2*pi);    t_out = ones(p.ndots,1);    for i=1:p.n_prop        if tb_min(i) < tb_max(i)            t_out = t_out & (t < tb_min(i) | t > tb_max(i));        else            t_out = t_out & (t < tb_min(i) & t > tb_max(i));        end    end        L = find(r_out | t_out | rand(p.ndots,1) < p.fkill);	% locus of all dots that have gone beyond borders or are killed    nL = length(L);        if nL                % choose new dot positions                r = rmax * sqrt(rand(nL,1));	% r        r(r<rmin) = rmin;        t(L) = rand(nL,1).*(p.th_max(pn(L))-p.th_min(pn(L)))+p.th_min(pn(L))+th;        xy(L,:) = [r r] .* [cos(t(L)), sin(t(L))];                mdir(L) = 2*pi*rand(nL,1);	% motion direction for each dot        mdir(coh) = cohdir;        dxdy(L,:) = pfs * [cos(mdir(L)), sin(mdir(L))];    end        xdots = xy;	% new dot positions to be drawn        Screen('FillRect', wp, BLACK_INDEX);    Screen('FillRect', wp, RED_INDEX, fix_cord);	% fixation dot    Screen('FillRect', wp, BLACK_INDEX, [fix_cord(1)+2, fix_cord(2)+2, fix_cord(3)-2, fix_cord(4)-2]);	% fixation dot    Screen('DrawDots', wp, xdots', p.dotsize, WHITE_INDEX, xy0, 2);    Screen('Flip', wp);        timing=GetSecs;    while GetSecs-timing < .0133                        %_______________check for responses        if check %get response for last targ letter                        if GetSecs > start_resp_time + resp_interval                check=0;                            end            [keyIsDown, secs, keycode] = KbCheckMulti; %check response                        if find(keycode(resp_key)) & trial_num >1 %if hit response key                behav_data(trial_num, 5)=1;%1 for hit response                check=0;                check_prior=1;                nkeypress = nkeypress + 1;                keypresses(ikp) = secs-start_time;                keythetas(ikp) = th;                ikp=ikp+1;                correctpress=correctpress+1;                            end        else            %then check            [keyIsDown, secs, keycode] = KbCheckMulti; %check response                        if find(keycode(resp_key))%if hit response key                if ~check_prior & trial_num > 1                    %add in a line in the data file                    falsecounter=falsecounter+1;                    behav_data(trial_num, 6)=behav_data(trial_num,6)+1; %record false alarm                    check_prior=1;                    nkeypress = nkeypress + 1;                    keypresses(ikp) = secs-start_time;                    keythetas(ikp) = th;                    ikp=ikp+1;                end                if ~check_prior & trial_num==1                    %add in a line in the data file                    falsecounter=falsecounter+1;                    behav_data(1, 6)=behav_data(1,6)+1; %record false alarm                    check_prior=1;                    nkeypress = nkeypress + 1;                    keypresses(ikp) = secs-start_time;                    keythetas(ikp) = th;                    ikp=ikp+1;                end                            else                %resp button not down                check_prior=0;            end                    end                %__________________end response check    end    end %---end while loopScreen('FillRect', wp, BLACK_INDEX);Screen('FillRect', wp, RED_INDEX, fix_cord);	% fixation dotScreen('FillRect', wp, BLACK_INDEX, [fix_cord(1)+2, fix_cord(2)+2, fix_cord(3)-2, fix_cord(4)-2]);	% fixation dotScreen('Flip', wp);WaitSecs(p.end_blank_time);GetSecs-start_time% kbwait;Screen('CloseAll');nswitch% keypress;correctpress;falsealarms=nkeypress-correctpress;ikp-1;tmp=clock;% figure(1);% plot (behav_data(:,2))accuracy=correctpress/nswitchfinal_set=[behav_data];save(filename, '-ascii', 'final_set');